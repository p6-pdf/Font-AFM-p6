use v6;

#
# This program creates metrics modules for some fonts and place them
# under the "Metrics" directory.
#
# Author: Gisle Aas
# Perl 5 -> 6 Port: David Warring

BEGIN %*ENV<GLYPHS> //= 'etc/glyphlist.txt';
BEGIN %*ENV<METRICS> //= 'etc/Core14_AFMs';

use lib 'lib';
use Font::AFM;
use Panda::Builder;
use Panda::Common;

class Build is Panda::Builder {

    method !build-metrics {

        for @Font::AFM::CoreFonts -> $font {
            my $class-name = Font::AFM.class-name( $font );
            my @parts = $class-name.split('::');
            my $mod-name = @parts.pop;
            my $lib-dir = $*SPEC.catdir('lib', |@parts);
            mkdir( $lib-dir, 0o755)
                unless $lib-dir.IO ~~ :e;

            my $afm = Font::AFM.new: $font;

            say "Building $font => $class-name";
            {
                my $gen-path = $*SPEC.catfile($lib-dir, "$mod-name.pm");
                my $*OUT = open( $gen-path, :w);

                my $metrics = %( $afm ).item;

                print q:s:c:to"--CODE-GEN--";
                use v6;
                # Font metrics for $font
                #
                # DO NOT EDIT!!!
                #
                # This file was auto-generated by {$*SPEC.abs2rel($?FILE)} based on the AFM file for the font.
                #
                # {$afm.Notice}

                use Font::AFM;

                class $class-name
                    is Font::AFM;

                --CODE-GEN--

                say "BEGIN our \$metrics = {$metrics.perl}";
                say '';
                say 'method new { self.bless( :$metrics ) }';
            }
        }
    }

    method !build-encodings {
        my $lib-dir = $*SPEC.catdir('lib', 'Font');
        mkdir( $lib-dir, 0o755);

        my $class-name = "Font::Encoding";
        my $encoding-path = %*ENV<GLYPHS>.IO;
        say "Building $encoding-path => $class-name";
        my $encoding-io = $encoding-path;

        die "unable to load encodings: $encoding-path"
            unless $encoding-path ~~ :e;

        my $glyph = {};
        my $encoding = {};

        for $encoding-path.lines {
            next if /^ '#'/ || /^ $/;
            my ($glyph-name,$ords-hex) = .split(';');
            my @code-points = $ords-hex.split(' ').map({ :16($_).chr });

            my $grapheme = [~] @code-points;
        
            # Assumes chars will commonly combine under Perl6 NFG - untested
            warn "$glyph-name: unable to combine characters $ords-hex: $grapheme"
                unless $grapheme.chars == 1;

            $encoding{$glyph-name} //= $grapheme.ord;
            $glyph{$grapheme.ord} //= $glyph-name;
        }

        {
            my $gen-path = $*SPEC.catfile($lib-dir, "Encoding.pm");
            my $*OUT = open( $gen-path, :w);

            print q:s:c:to"--CODE-GEN--";
            use v6;
            # Font Encodings
            #
            # DO NOT EDIT!!!
            #
            # This file was auto-generated by {$*SPEC.abs2rel($?FILE)} based on $encoding-path

            class $class-name;

            --CODE-GEN--

            say "BEGIN our \$glyph = {$glyph.perl};";
            say "";
            say "BEGIN our \$encoding = {$encoding.perl};";
        }
    }

    method build($where) {

        indir $where, {
            my $encoding-path = %*ENV<ENCODINGS> // $*SPEC.catfile( 'etc', 'encodings.txt ');
            self!"build-encodings"();
            self!"build-metrics"();
        }
    }
}

# Build.pm can also be run standalone 
sub MAIN(:$indir = '.', :$metrics-path?, :$glyphs-path ) {

    %*ENV<METRICS> = $metrics-path
        if $metrics-path.defined;

    %*ENV<GLYPHS> = $glyphs-path
        if $glyphs-path.defined;

    Build.new.build($indir);
}
