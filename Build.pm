use v6;

#
# This program creates metrics modules for some fonts and place them
# under the "Metrics" directory.
#
# Author: Gisle Aas
# Perl 5 -> 6 Port: David Warring

BEGIN %*ENV<GLYPHS> //= 'etc/glyphlist.txt';
BEGIN %*ENV<METRICS> //= 'etc/Core14_AFMs';

use lib 'lib';
use Font::AFM;
use Panda::Builder;
use Panda::Common;

BEGIN our @FONTS = <Courier
    Courier-Bold
    Courier-Oblique
    Courier-BoldOblique

    Helvetica
    Helvetica-Bold
    Helvetica-Oblique
    Helvetica-BoldOblique
  
    Times-Roman
    Times-Bold
    Times-Italic
    Times-BoldItalic
    >;

class Build is Panda::Builder {

    method !build-metrics {
        my $lib-dir = $*SPEC.catdir('lib', 'Font', 'Metrics');
        mkdir( $lib-dir, 0o755);

        for @FONTS -> $font {
            (my $fontmod = $font) ~~ s:g/'-'//;
            my $class-name = "Font::Metrics::$fontmod";
            my $afm = Font::AFM.new: $font;

            say "Building $font => $class-name";
            {
                my $gen-path = $*SPEC.catfile($lib-dir, "$fontmod.pm");
                my $*OUT = open( $gen-path, :w);

                my $metrics = %( $afm ).item;

                print q:s:c:to"--CODE-GEN--";
                use v6;
                # Font metrics for $font
                #
                # DO NOT EDIT!!!
                #
                # This file was auto-generated by {$*SPEC.abs2rel($?FILE)} based on the AFM file for the font.
                #
                # {$afm.Notice}

                use Font::AFM;

                class $class-name
                    is Font::AFM;

                --CODE-GEN--

                say "BEGIN our \$metrics = {$metrics.perl}";
                say '';
                say 'method new { self.bless( :$metrics ) }';
            }
        }
    }

    method !build-encodings {
        my $lib-dir = $*SPEC.catdir('lib', 'Font');
        mkdir( $lib-dir, 0o755);

        my $class-name = "Font::Encoding";
        my $encoding-path = %*ENV<GLYPHS>.IO;
        say "Building $encoding-path => $class-name";
        my $encoding-io = $encoding-path;

        die "unable to load encodings: $encoding-path"
            unless $encoding-path ~~ :e;

        my @latin1;
        my $glyphs = {};

        for $encoding-path.lines {
            next if /^ '#'/ || /^ $/;
            my ($glyph,$ords-hex) = .split(';');
            my @code-points = $ords-hex.split(' ').map({ :16($_).chr });

            my $grapheme = [~] @code-points;
        
            if $grapheme.chars == 1 && $grapheme.ord <= 255 && $glyph !~~ /^'control'/ {
                # latin1-ish
                @latin1[ $grapheme.ord ] //= $glyph
            }
  
            # Assumes chars will commonly combine under Perl6 NFG - untested
            warn "$glyph: unable to combine characters $ords-hex: $grapheme"
                unless $grapheme.chars == 1;

            $glyphs{$glyph} //= $grapheme.ords;
        }

        for @latin1.keys {
             @latin1[$_] //= '.notdef';
        }

        {
            my $gen-path = $*SPEC.catfile($lib-dir, "Encoding.pm");
            my $*OUT = open( $gen-path, :w);

            print q:s:c:to"--CODE-GEN--";
            use v6;
            # Font Encodings
            #
            # DO NOT EDIT!!!
            #
            # This file was auto-generated by {$*SPEC.abs2rel($?FILE)} based on $encoding-path

            class $class-name;

            --CODE-GEN--

            say "BEGIN our \$latin1 = {@latin1.item.perl};";
            say "";
            say "BEGIN our \$glyphs = {$glyphs.perl};";
        }
    }

    method build($where) {

        indir $where, {
            my $encoding-path = %*ENV<ENCODINGS> // $*SPEC.catfile( 'etc', 'encodings.txt ');
            self!"build-encodings"();
            self!"build-metrics"();
        }
    }
}

# Build.pm can also be run standalone 
sub MAIN(:$indir = '.', :$metrics-path?, *@font-names ) {

    %*ENV<METRICS> = $metrics-path
        if $metrics-path.defined;

    @FONTS = @font-names
        if +@font-names;

    Build.new.build($indir);
}
